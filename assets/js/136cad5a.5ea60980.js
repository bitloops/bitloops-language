"use strict";(self.webpackChunkbitloops_com_docs=self.webpackChunkbitloops_com_docs||[]).push([[83],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),h=d(a),p=i,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||o;return a?n.createElement(m,s(s({ref:t},c),{},{components:a})):n.createElement(m,s({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,s=new Array(o);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[h]="string"==typeof e?e:i,s[1]=r;for(var d=2;d<o;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},3848:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var n=a(7462),i=(a(7294),a(3905));const o={sidebar_position:1,sidebar_label:"Domain Driven Design",title:"Domain Driven Design - What is it and how to apply it?",description:"Learn how to build software systems that align with your business needs and understand the key concepts of Domain-Driven Design (DDD), including bounded contexts, aggregates, and ubiquitous language. Whether you're a developer, architect, or project manager, this comprehensive DDD review will equip you with the knowledge and insights you need to design more effective software systems.",keywords:["domain driven design","ddd","bounded context","ubiquitous language","context mapping","Eric Evans"]},s="Domain-Driven Design",r={unversionedId:"learning/software-design/domain-driven-design",id:"learning/software-design/domain-driven-design",title:"Domain Driven Design - What is it and how to apply it?",description:"Learn how to build software systems that align with your business needs and understand the key concepts of Domain-Driven Design (DDD), including bounded contexts, aggregates, and ubiquitous language. Whether you're a developer, architect, or project manager, this comprehensive DDD review will equip you with the knowledge and insights you need to design more effective software systems.",source:"@site/docs/learning/software-design/domain-driven-design.md",sourceDirName:"learning/software-design",slug:"/learning/software-design/domain-driven-design",permalink:"/docs/bitloops-language/learning/software-design/domain-driven-design",draft:!1,editUrl:"https://github.com/bitloops/bitloops-language/edit/main/documentation/docs/learning/software-design/domain-driven-design.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Domain Driven Design",title:"Domain Driven Design - What is it and how to apply it?",description:"Learn how to build software systems that align with your business needs and understand the key concepts of Domain-Driven Design (DDD), including bounded contexts, aggregates, and ubiquitous language. Whether you're a developer, architect, or project manager, this comprehensive DDD review will equip you with the knowledge and insights you need to design more effective software systems.",keywords:["domain driven design","ddd","bounded context","ubiquitous language","context mapping","Eric Evans"]},sidebar:"tutorialSidebar",previous:{title:"Software Design",permalink:"/docs/bitloops-language/category/software-design"},next:{title:"Behavior Driven Development",permalink:"/docs/bitloops-language/learning/software-design/behavior-driven-development"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"What is Domain-Driven Design?",id:"what-is-domain-driven-design",level:3},{value:"Why learn Domain-Driven Design?",id:"why-learn-domain-driven-design",level:3},{value:"What is \u201cDomain\u201d in DDD?",id:"what-is-domain-in-ddd",level:3},{value:"Strategic: Building a Domain Model",id:"strategic-building-a-domain-model",level:2},{value:"Domains and Subdomains",id:"domains-and-subdomains",level:3},{value:"Core Domain",id:"core-domain",level:4},{value:"Supporting Domain",id:"supporting-domain",level:4},{value:"Generic Domain",id:"generic-domain",level:4},{value:"Ubiquitous Language",id:"ubiquitous-language",level:3},{value:"Bounded Context",id:"bounded-context",level:3},{value:"Context Mapping",id:"context-mapping",level:3},{value:"Tactically: Implementing DDD",id:"tactically-implementing-ddd",level:2},{value:"User Interface",id:"user-interface",level:3},{value:"Controllers",id:"controllers",level:4},{value:"Data Transfer Objects (DTOs)",id:"data-transfer-objects-dtos",level:4},{value:"Application Layer",id:"application-layer",level:3},{value:"Application Services",id:"application-services",level:4},{value:"Commands and Queries",id:"commands-and-queries",level:4},{value:"Side effects",id:"side-effects",level:4},{value:"Ports",id:"ports",level:4},{value:"Factories",id:"factories",level:4},{value:"Domain Layer",id:"domain-layer",level:3},{value:"Domain Objects",id:"domain-objects",level:4},{value:"Entities",id:"entities",level:4},{value:"Value objects",id:"value-objects",level:4},{value:"Aggregates",id:"aggregates",level:4},{value:"Aggregate Design Guidelines",id:"aggregate-design-guidelines",level:4},{value:"Events (Domain &amp; Integration)",id:"events-domain--integration",level:4},{value:"Domain Invariants",id:"domain-invariants",level:4},{value:"Domain Errors",id:"domain-errors",level:4},{value:"Domain Services",id:"domain-services",level:4},{value:"Infrastructure Layer",id:"infrastructure-layer",level:3},{value:"Adapters",id:"adapters",level:4},{value:"Repositories",id:"repositories",level:4},{value:"Data Access Objects (DAOs)",id:"data-access-objects-daos",level:4},{value:"Persistence",id:"persistence",level:4},{value:"DDD: Benefits &amp; Challenges",id:"ddd-benefits--challenges",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Challenges",id:"challenges",level:3},{value:"Other DDD complimentary patterns",id:"other-ddd-complimentary-patterns",level:2},{value:"DDD &amp; Service Oriented Architecture",id:"ddd--service-oriented-architecture",level:3},{value:"Domain-Driven Design Microservices",id:"domain-driven-design-microservices",level:3},{value:"DDD and Event-Driven Architecture",id:"ddd-and-event-driven-architecture",level:3},{value:"Object Oriented Programming (OOP)",id:"object-oriented-programming-oop",level:3},{value:"Dependency Injection (DI)",id:"dependency-injection-di",level:3},{value:"Aspect Oriented Programming (AOP)",id:"aspect-oriented-programming-aop",level:3},{value:"Behavior-Driven Development (BDD)",id:"behavior-driven-development-bdd",level:3},{value:"Bitloops -&gt; Simplifying DDD",id:"bitloops---simplifying-ddd",level:2},{value:"DDD Programming Language",id:"ddd-programming-language",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:d},h="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(h,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"domain-driven-design"},"Domain-Driven Design"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Domain-Driven Design (DDD) is a software development approach or methodology that focuses on developing a deep and thorough understanding of a domain (think business problem), and creating a model that maps out the processes and rules of said domain."),(0,i.kt)("p",null,"It's important to clarify up-front that DDD is not about programming languages, infrastructure technologies or software architecture. DDD is simply a set of patterns and good practices that enables the development of software. More specifically, DDD was envisaged to support development teams in understanding complex domains, and simplifying the subsequent development of systems that adequately map that domain. In fact, DDD is based on Eric Evan\u2019s book \u201cDomain Driven Design: Tackling Complexity in Software\u201d, which, as per the title, is precisely targeting complex systems.",(0,i.kt)("br",{parentName:"p"}),"\n",""),(0,i.kt)("h3",{id:"what-is-domain-driven-design"},"What is Domain-Driven Design?"),(0,i.kt)("p",null,"The ultimate goal of DDD is to model software that domain experts understand and agree with. This essentially builds a strong, consistent and reliable communication channel between all stakeholders, and more specifically between domain experts (business specialists) and software engineers (Product & Tech)."),(0,i.kt)("p",null,"In order to achieve this, DDD is generally thought of from 2 perspectives:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Strategic: this refers to a higher level modeling of the domain by using a ubiquitous language, breaking up a system into bounded contexts and clearly defining the context maps, ensuring the entire team/organization is aligned."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Tactical: this is commonly referred to as the building blocks of DDD as it is a bit more spec- ific in nature and helps engineers more clearly define these rules and processes. This includes entities, Value Objects, Services, Repositories, etc. which we explain further below."),"\n","\xa0"))),(0,i.kt)("h3",{id:"why-learn-domain-driven-design"},"Why learn Domain-Driven Design?"),(0,i.kt)("p",null,"DDD is not an easy methodology to learn. There are several components which we describe below, and the learning curve is quite steep. Moreover, given it is a development methodology only works if the entire organization is behind it, requiring buy-in from several stakeholders."),(0,i.kt)("p",null,"If you\u2019re working in a complex domain with significant \u201cmessy\u201d logic that needs to be well organized, then DDD is likely to be an interesting solution. Knowing if your system is or will be complex enough to warrant DDD is very tricky and more of an art than a science. In fact, Vaugh Vernon, another DDD guru, developed a scorecard (nicely described in his book \u201cImplementing Domain-Driven Design\u201d) that helps users identify the level of complexity of an application and determine if it's worth applying DDD or not."),(0,i.kt)("p",null,"However, the trouble with complexity is that it\u2019s not easily defined given its relative to each person, domain and situation. We intuitively know what complexity is, but quantifying is a lot harder. Moreover, software systems today are more like living and evolving organisms that can easily and quickly take on additional complexity, so it's important to take this into account as well."),(0,i.kt)("p",null,"Given Domain-Driven Design is all about managing complexity, and complexity is increasingly a part of our lives (software development included), learning how to manage complexity is definitely something everyone can benefit from. Moreover, we at Bitloops are reducing the learning curve and making it much easier to learn and implement DDD whilst building software - so much so, that we actually believe most projects would benefit from starting their application with a DDD mindset, and evolve their understanding of DDD as their application evolves. It's certainly better than not trying."),(0,i.kt)("h3",{id:"what-is-domain-in-ddd"},"What is \u201cDomain\u201d in DDD?"),(0,i.kt)("p",null,"A domain is the heart of any organization, and consequently critical in defining the software the organization uses to execute its mission. If you look up \u201cdomain\u201d in the dictionary, it states that it is a sphere of knowledge, which means it's the set of rules, requirements, processes and guidelines that define how an organization interacts with its customers, partners, suppliers and any other relevant stakeholders. Simply put, it's the area of knowledge around which the application revolves."),(0,i.kt)("p",null,"This concept may seem intuitive to most, however, it is critical to clearly appreciate the importance of having a clear understanding across the organization of the domain. Only through this clarity will it be possible to create a domain model example for a specific industry or company."),(0,i.kt)("p",null,"Having clarity of a domain will facilitate the design of robust domain models, together with the other principles mentioned below. A robust domain model has several benefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Improves communication across the organization"),(0,i.kt)("li",{parentName:"ul"},"Allows systems to be easily managed and maintained"),(0,i.kt)("li",{parentName:"ul"},"Enables faster development of new features, extensions and improvements / iterations")),(0,i.kt)("p",null,"Domain models must focus on a specific business operational domain, and should align with the business model, strategies and business processes."),(0,i.kt)("p",null,"For example, two car insurance companies operating in a specific country are very likely to have 2 very different domain models. They have different strategies, business models and processes. One might be focusing on the direct to consumer model, and the other relies on insurance agents. Just this difference is enough to completely change their domain models."),(0,i.kt)("p",null,"Another important principle to consider is the isolation of domain models between each other. DDD focuses on ensuring separation between business logic and technological aspects, however, it is equally important to ensure domain models are reusable and that there are no duplicate implementations of the same domain model. This can only be achieved by ensuring domain models are loosely coupled with other layers, allowing for easier maintenance, testing and versioning."),(0,i.kt)("p",null,"\xa0",(0,i.kt)("br",{parentName:"p"}),"\n",""),(0,i.kt)("h2",{id:"strategic-building-a-domain-model"},"Strategic: Building a Domain Model"),(0,i.kt)("p",null,"In order to accurately build a domain model, it's crucial to first understand that domain, which can only be done with a common language. Subsequently, it is necessary to separate the model into adequate modules and define how they integrate with each other."),(0,i.kt)("p",null,"Explaining 4 key components of DDD is necessary:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Domain / Subdomains"),(0,i.kt)("li",{parentName:"ul"},"Ubiquitous Language"),(0,i.kt)("li",{parentName:"ul"},"Bounded Contexts"),(0,i.kt)("li",{parentName:"ul"},"Context Maps")),(0,i.kt)("h3",{id:"domains-and-subdomains"},"Domains and Subdomains"),(0,i.kt)("p",null,"As described above, the concept of a domain can be very broad and sometimes it's easier to break it up into smaller parts called subdomains."),(0,i.kt)("p",null,"This is easier said than done because finding these subdomains is not always immediately clear. Nevertheless, identifying these separate parts brings tremendous value to the product development and management. Essentially, there are 3 types of subdomains, and each has a different priority level:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Core Domains"),(0,i.kt)("li",{parentName:"ul"},"Supporting Domains"),(0,i.kt)("li",{parentName:"ul"},"Generic Domains")),(0,i.kt)("p",null,"Whilst all subdomains are important for the overall success of a project, each will require different amounts of effort, and the quality required of each will differ. It's also interesting to note that specific subdomains may be considered supporting subdomain in 1 organization, but considered core or even generic in another. The key thing to understand is the context in which that subdomain is being used."),(0,i.kt)("h4",{id:"core-domain"},"Core Domain"),(0,i.kt)("p",null,"The most important domain of a project are the core domains. This is what makes a product unique, and generally what adds the most value to the users. This is normally the domain with the highest priority, greatest effort, best resources and the domain in which the organization needs to really excel at."),(0,i.kt)("p",null,"Small projects may have only 1 core domain, whilst larger, more complex projects may have several core domains."),(0,i.kt)("h4",{id:"supporting-domain"},"Supporting Domain"),(0,i.kt)("p",null,"A supporting domain, as the name suggests, is a domain the supports the execution of the project, but is not critical. This type of domain does require some customization or specialization depending on the project and organization, but is not something unique to that project."),(0,i.kt)("p",null,"In many instances, supporting domains are built taking existing solutions, and tweaking them to fit the needs of the project or organization"),(0,i.kt)("h4",{id:"generic-domain"},"Generic Domain"),(0,i.kt)("p",null,"A generic subdomain is any domain that can be easily outsourced or provided by a standard solution in the market. It does not contain any special features, nor is it unique to an organization. It is required for the project to work, but there are probably a number of solutions that could be considered."),(0,i.kt)("h3",{id:"ubiquitous-language"},"Ubiquitous Language"),(0,i.kt)("p",null,"This is quite possibly the most important aspect to DDD. If teams & organizations are able to agree and adopt a ubiquitous language for their product development, then the investment in learning and implementing DDD will be worth it."),(0,i.kt)("p",null,"A Ubiquitous Language is essentially all the terms and words used to define the domain model, and is generally created through collaboration with domain experts. This language is then used by all team members when discussing activities related to the team\u2019s application.\nUsing the same terminology improves communication and cohesion between technical and non-technical team members, as well as reduces misunderstandings and errors. In fact, nouns and common verbs of a domain are frequently used to name classes and services respectively, which makes the code easier to read and understand."),(0,i.kt)("h3",{id:"bounded-context"},"Bounded Context"),(0,i.kt)("p",null,"If life were simple, we could model a domain using one ubiquitous language and a single model. However, the world is more complicated than that, and for the exception of very small and simple projects, most businesses have complex business rules and overlapping processes. In order to solve this, we generally break up a domain (core, supporting or generic) into distinct parts, each having its own dialect of the ubiquitous language. This dividing of the domain into smaller parts that are somewhat independent of each other and have clearly defined boundaries are called bounded contexts."),(0,i.kt)("p",null,"A Bounded Context is a conceptual boundary that contains parts of an application that fit into a specific model. This is typically a subsystem or the work of a specific team, and revolves around a specific business domain. In fact, very often, teams are split according to bounded contexts, each of them specializing in their own domain expertise and logic.\nThe reason bounded contexts are created is that groups related components & concepts, and significantly reduces the possibility of ambiguity as some of these could have similar meanings without a clear context.\nIt is important to note though that whilst a bounded context represents discrete entities, they do contain both unrelated and shared concepts between them, and we use context maps to define the relationships between these bounded contexts for those shared concepts.\nFor example, outside of a Bounded Context, the term \u201cdelivery\u201d could mean two very different things: either a delivery route or an object being delivered. By defining a boundary and context, you can determine its meaning"),(0,i.kt)("p",null,"'''\nBounded contexts should be thought of as black boxes that operate in their own world and don\u2019t need or care about how other parts of the system work. This doesn\u2019t mean bounded contexts don\u2019t speak to each other, it only means that you should design the process of retrieving and processing data from other bounded contexts in specific ways such as repositories or domain services (discussed below) and not implement cross-db stored procedures to retrieve specific data.\n'''"),(0,i.kt)("h3",{id:"context-mapping"},"Context Mapping"),(0,i.kt)("p",null,"Once bounded contexts are defined, the next pertinent step is to define how these bounded contexts interact between them. Teams need to communicate and work together on features, and having clarity on the boundaries, as well as the collaboration expectations will greatly improve speed and quality of development."),(0,i.kt)("p",null,"When defining these relationships, it is prudent to take into consideration how to build robust, flexible relationships that empower developers and don\u2019t limit them. These are some of the most relevant considerations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Anti-corruption layer: a downstream bounded context implements a layer that translates data or objects that come from a higher level (upstream) bounded context, so that it supports the internal model"),(0,i.kt)("li",{parentName:"ul"},"Conformist: downstream (child) bounded contexts conform and adopt to upstream (parent) bounded contexts, which places the responsibility on the downstream bounded context in meeting the requirements specified by the upstream bounded context"),(0,i.kt)("li",{parentName:"ul"},"Customer/supplier: Upstream bounded contexts supplies downstream bounded contexts with a service and downstream bounded contexts simply act as a customer, determining requirements and requesting changes to the upstream bounded context to meet their needs"),(0,i.kt)("li",{parentName:"ul"},"Shared kernel: there are situations where bounded contexts overlap, and it's not possible to simply assign it to a specific bounded context. In this case, the relationship requires that both bounded contexts be continuously in sync when changes are required. This type of relationship should be avoided as it will likely lead to issues")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Kernel:"))," Sometimes, contexts share common code, and this is referred to as the kernel. The kernel is accessible by both contexts, but the respective teams need to be collaborative when making changes to ensure there are no unintended side effects. It helps if you have automatic testing and continuous integration. The easiest solution is to avoid kernels, or have them as simple as possible.")),(0,i.kt)("p",null,"\xa0",(0,i.kt)("br",{parentName:"p"}),"\n",""),(0,i.kt)("h2",{id:"tactically-implementing-ddd"},"Tactically: Implementing DDD"),(0,i.kt)("p",null,"Once a domain model has been defined, the next logical step is to proceed to its implementation, following practices and patterns that can most adequately translate the domain model into domain logic and ultimately into code."),(0,i.kt)("p",null,"As clarified above, a key DDD consideration is the definition of bounded contexts that separate or delineate business logic into cohesive and manageable modules. The same concept applies to the actual software development process: there is a need to isolate the domain from other aspects related to code or infrastructure."),(0,i.kt)("p",null,"Code that is written to solve domain problems or logic is only a fraction of the entire codebase that is required to get an application working. And, it is imperative that this code not be intertwined with code that solves or manages other functionality. By separating domain logic from all other functionality (as well as clearly separating those functionalities into their individual parts), reduces confusion in large and complex systems."),(0,i.kt)("p",null,"To achieve this, the original DDD thinkers propose a layered architecture as a way to separate different functionalities. More specifically, the layered architecture suggests splitting the code base into 4 layers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"User Interface:")," This layer is responsible for presenting information to the user and interpreting user commands"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Application Layer:")," Coordinates and orchestrates the activities of the application. This layer does not contain any business logic and it does not hold any state of business objects, only state of an application task\u2019s progress"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Domain Layer:")," Contains information, rules and logic about the business domain. This layer holds the state of business objects, however, the persistence of the business objects and possibly their state is delegated to the infrastructure layer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Infrastructure Layer:")," Provides communication between layers, implements persistence for business objects, contains supporting libraries for the user interface layer, and acts as a supporting library for all the other layers.")),(0,i.kt)("p",null,"Essentially, the idea is that each layer only depends on the components within that layer, or components of any layer beneath it by calling their public interfaces. Lower layers can only communicate upwards by something called ",(0,i.kt)("a",{parentName:"p",href:"https://martinfowler.com/bliki/InversionOfControl.html"},"Inversion of Control (IoC)"),"."),(0,i.kt)("p",null,"This goal to segregate an application into different tiers empowers developers to build robust, maintainable and flexible systems. However, there are different subsets of layered architectures, and each has their own pros and cons. The common theme across all of them is the need to partition the application into layers or components, and then develop a design for each component that is cohesive, ensuring the domain model code is concentrated in the domain layer or component."),(0,i.kt)("p",null,"In fact, Alistair Cockburn realized in 2005 that the user interface and the database interact with the application in very similar ways and that by defining ports and adaptors, the application could become \u201cagnostic\u201d to these external components, reducing even further the entanglement and scattering of business logic across layers / components, which would further increase the systems\u2019 robustness and flexibility. This insight created the ",(0,i.kt)("a",{parentName:"p",href:"https://alistair.cockburn.us/hexagonal-architecture/"},"Hexagonal Architecture"),", which marries very well with DDD, and one which is used to describe many of the components below"),(0,i.kt)("h3",{id:"user-interface"},"User Interface"),(0,i.kt)("p",null,"Irrespective of the software architecture choice, something that is consistent is the existence of a user interface. This is normally responsible for displaying information to the user and interpreting the user\u2019s commands. The \u201cuser\u201d may be a human on a desktop or mobile device, or another computer system that interacts with this system."),(0,i.kt)("p",null,"User interfaces need to manage communication between the users and the application layer. These adaptors take input data from the user, repackage it so it can be inserted into the use cases and services. The outputs from the use cases and services are then repackaged again in a form that is convenient to display back to the user, or send to another server/device."),(0,i.kt)("h4",{id:"controllers"},"Controllers"),(0,i.kt)("p",null,"A controller is a user-facing API that parses requests, triggering domain logic and then presenting back the result to the client in a http format. Generally you create one controller per use case and is normally considered part of the UI layer, however, there are some that believe it is better placed in the application layer."),(0,i.kt)("p",null,"Essentially, a controller is servicing requests from the UI, and by separating the code required to execute this request, the less \u201ccomplicated\u201d the application services are. Moreover, these controllers can be used repeatedly across the application if required."),(0,i.kt)("h4",{id:"data-transfer-objects-dtos"},"Data Transfer Objects (DTOs)"),(0,i.kt)("p",null,"A DTO is a special type of class that represents data that comes from external applications. This object carries data between processes and defines the contract between two services (an API and the client for example). There are two types of DTOs:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Request DTO:")," input data sent by a user, following the agreed contract to make a valid request"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Response DTO:")," output data returned to a user, following the agreed contract and data sent by the request DTO")),(0,i.kt)("p",null,"From a DDD perspective, DTO's help maintain the separation between Application and UI layers, and protect internal data structure changes. For example, when there is a change to an internal data model (such as renaming a value object or splitting tables), these can still be mapped to match the corresponding DTO to ensure compatibility. Therefore, Domain Objects are used in the domain and service layers and DTO's are used in the presentation layer."),(0,i.kt)("p",null,"Another point to note is that DTOs should be data-oriented and not object-oriented, meaning they should not have any modeling attached to them and simply send data from one place to another. Adding any type of logic or modeling to a DTO can cause confusion and bugs in the future."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Advanced note:")," the concept of a Local DTO exists in situations where you want to decouple internal modules properly. For example, if you\u2019re querying from one module to another and you want to ensure clear separation between these modules so there can be no \u201cspillage\u201d, then a local DTO may be justified. The only caveat is that it increases the need to manage additional data mapping.")),(0,i.kt)("h3",{id:"application-layer"},"Application Layer"),(0,i.kt)("p",null,"This layer is responsible for managing and orchestrating all the services and steps required to execute the commands requested by the client."),(0,i.kt)("p",null,"From a user perspective, the Application Layer orchestrates the navigation between UI screens or interactions between other systems. In general, the application layer does not perform business logic, however it can perform non-business related validation on user input, before sending it to the domain layer. Therefore, the application layer doesn\u2019t have any business or domain related logic, nor data access logic. It also doesn\u2019t hold any state of an object or a use case, but it can manage the state of a user session or progress of a service."),(0,i.kt)("h4",{id:"application-services"},"Application Services"),(0,i.kt)("p",null,"Within the Application Layer there are application services that orchestrate the steps required to fulfill operations triggered by users/systems. These application services are sometimes called workflow service, use cases or interactors."),(0,i.kt)("p",null,"The idea is that these application services manage the communication between the entire application, connecting the user interface, the domain logic and even the infrastructure to work as one. They are responsible for retrieving input data from outside of the domain, returning information or data due to a specific action or \u201clistens\u201d for events and decides what it needs to trigger based on each event."),(0,i.kt)("p",null,"Essentially, application services are responsible for ensuring that what should happen does happen by orchestrating all the communication that is feed in and out of a system"),(0,i.kt)("p",null,"It is important to note that there are services in the domain, infrastructure and application layers, but each has their own task and responsibility."),(0,i.kt)("h4",{id:"commands-and-queries"},"Commands and Queries"),(0,i.kt)("p",null,"There are two types of operations that application services execute:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Commands")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Queries"))),(0,i.kt)("p",null,"Commands change systems by changing data, and it generally indicates user intent. Operations such as create, update and delete are commands as they change the state of an object."),(0,i.kt)("p",null,"Queries retrieve information from the system without making any change. It does not write to a database, file or interact with any third party API). This operation reads data by signaling the user's intention to find something and provide a description."),(0,i.kt)("p",null,"Following these operations, a pattern has emerged called CQRS (command and query responsibility segregation) which advocates for the strict separation between your command and query operations. In essence, it declares that commands should only update data and queries should only read data. The benefits are improved performance, scalability, security and flexibility as the system is better able to evolve over time and prevents update commands from causing merge conflicts at the domain level."),(0,i.kt)("h4",{id:"side-effects"},"Side effects"),(0,i.kt)("p",null,"Side effects are common features of complex applications. A function calls another one, which calls another and so forth, leading to a deep nesting where the intended and unintended consequences become unclear. The unintended effects in the third or fourth tier operations become the side effects, which can lead to errors and bugs in the system."),(0,i.kt)("h4",{id:"ports"},"Ports"),(0,i.kt)("p",null,"Ports are a key component of the Hexagonal Architecture, as they abstract the technology details that business logic does not care about. In fact, the proper use of Ports can make applications extremely robust and versatile as they\u2019re able to switch between technologies with ease."),(0,i.kt)("p",null,"Basically, Ports are interfaces that define what has to be done, without explaining how that should be done (this is left to the adaptors as it may be used by several different systems)."),(0,i.kt)("p",null,"In addition, Ports abstract database access, technology details, invasive libraries, I/O operations and even legacy code from the core domain. This greatly simplifies the description of the domain itself, making it more robust."),(0,i.kt)("p",null,"An interesting analogy is to think about USB Ports. All computers have them, and they allow communication with a computer/laptop. The device that connects to it (a mouse, screen, hard-drive, phone, etc.) has a USB adaptor so that it can communicate through the USB port to the computer. The same principle applies to Ports and Adapters in the Hexagonal Architecture pattern."),(0,i.kt)("h4",{id:"factories"},"Factories"),(0,i.kt)("p",null,"Whenever a system needs to create a new object, it is good practice to use a Factory. Factories are objects with a single responsibility: create other objects."),(0,i.kt)("p",null,"Factories are particularly useful when you need to create entire and large aggregates, or complex value objects. The reason is that it provides encapsulation. By creating an interface, the assembly complexity is simplified, centralized and can be more easily changed or improved.\nThere are other benefits in using factories versus constructors:\nNaming: Factories allow you to given new, meaningful names to the new objects created\nPolymorphism: a constructor will only every create the exact same type of object, however a factory can return a different subclass\nCoupling: by using factory methods, you\u2019re more likely to code using interface than implementation, which embeds flexibility into your code"),(0,i.kt)("h3",{id:"domain-layer"},"Domain Layer"),(0,i.kt)("p",null,"The whole objective of domain-driven design is to isolate and model the domain with code, in a way that remains flexible, robust, maintainable and performant. This is the focus of the domain layer where all business domain concepts, use cases and business rules are represented."),(0,i.kt)("p",null,"The domain layer is essentially the heart of a business application, and should be clearly isolated from the other layers of the application. This is where domain objects are defined, and where the behavior and state of these business entities are encapsulated."),(0,i.kt)("p",null,"A key component of domain logic are the business rules. These define what data is valid, what constraints need to be applied and how/if this changes depending on the context. A business object may be treated differently if the context is different. These business rules also define how data is transformed, what decisions need to be taken and what needs to be done next (workflow)."),(0,i.kt)("p",null,"The key to building a great domain layer is of course clearly defining the domain model. Poor modeling will lead to an anemic domain model that translates into a poorly defined domain layer, and you end up with a large amount of business logic scattered (and duplicated) across the application, infrastructure and even user interface layers.\nOnce a high-quality domain model has been created, the next step is to implement it using the most appropriate objects and elements, which are described below."),(0,i.kt)("h4",{id:"domain-objects"},"Domain Objects"),(0,i.kt)("p",null,"Domain objects are objects from the business specific area that represent something meaningful to the domain expert. DOs are mostly represented by entities and value objects."),(0,i.kt)("h4",{id:"entities"},"Entities"),(0,i.kt)("p",null,"Entities represent concepts in the domain problem that have a unique identity (which does not change over time) and have a life cycle. Entities are composed of value objects and relation to other entities. As in the case of value objects, they are responsible for hiding and protecting its internal state from being \u201cinvalid\u201d. This is often called protecting invariants in wise DDD books. Basically it means that methods in our entity class should make sure that the execution of the given operation is allowed in its current state and that the result of such execution is in accordance with business rules."),(0,i.kt)("p",null,"Entity should push as much behavior as possible to value objects and other entities it is composed of. It should \u201corchestrate\u201d them and update its state based on the results. Sometimes entities must use domain services to perform some business logic. In such cases, we usually pass domain service reference to an entity method that needs it."),(0,i.kt)("h4",{id:"value-objects"},"Value objects"),(0,i.kt)("p",null,"Value objects are the basic building blocks of any domain model and define important concepts in the business domain. Value objects are immutable and replaceable, and unlike entities, have no lifecycle. The lack of value objects may indicate that the entities are overloaded with responsibilities."),(0,i.kt)("h4",{id:"aggregates"},"Aggregates"),(0,i.kt)("p",null,"Aggregate is the most powerful tactical pattern but also the hardest to get right. As bounded contexts divide our application into smaller areas focused on certain business capabilities, aggregates divide bounded contexts into smaller groups of classes, where each group represents concepts closely related to each other that work together."),(0,i.kt)("p",null,"With this pattern we should decompose large models into smaller clusters of domain objects.A group of connected value objects and entities form an aggregate."),(0,i.kt)("p",null,"Within each aggregate, there should be one class that is a gateway to functionality offered by thee entire aggregate is called the aggregate root."),(0,i.kt)("p",null,"Aggregates form a transactional consistency boundary, which means changes to an aggregate should be persisted in one database transaction or the whole state change should be rolled back."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Encapsulation:","_")," a term used frequently to describe good, clean code, but what does it mean?\nEncapsulation means grouping or bundling everything which is internal to a specific class such as data, methods, restrictions inaccessible to other classes, functions or services. Nothing else within a system (or outside it), need to know how a class manages its internal data and state.")),(0,i.kt)("h4",{id:"aggregate-design-guidelines"},"Aggregate Design Guidelines"),(0,i.kt)("p",null,"In order to create aggregates, it's important to understand and follow a few guidelines:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Keep them as small as possible:")," Because aggregates are retrieved and stored as a whole, the smaller they are, the less data is used")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Create an Aggregate ID:")," If aggregates store their aggregate root ID in a value object, then you can reference the aggregate via the value object. This simplifies aggregate consistency boundaries as it makes it almost impossible to change the stage of one aggregate from another. In essence, you want to avoid bidirectional relationships between aggregates.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Only change a single aggregate during a transaction:")," Avoid (sometimes its not possible) to only change one aggregate inside a single transaction. You should ideally use domain events and eventual consistency for operations that cut across several aggregates. Again, by doing this you avoid unintentional side effects.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Implement optimistic locking:")," one of the key principles and benefits of aggregates is to enforce business invariants and ensure consistency. Therefore it is best to use optimistic locking when saving aggregate to prevent data loss."))),(0,i.kt)("h4",{id:"events-domain--integration"},"Events (Domain & Integration)"),(0,i.kt)("p",null,"Events allow systems to be designed with an event driven architecture, which allows for reducing coupling between components. Generally, events represent an important business event in the domain and are represented with specific ubiquitous language. They are also used in a publish-subscribe manner to trigger other commands or services."),(0,i.kt)("p",null,"Events can be considered:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Domain events:")," used within a specific bounded context and can reference domain objects, and are commonly used to synchronize state of different aggregates or subscribe to events in the application services and perform infrastructure related tasks"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Integration events:")," are events used to synchronize between bounded contexts, particularly useful when building microservices. These events cannot reference domain objects, usually contain only identifiers of all aggregates which changed state and should use simple types so other systems are able to interpret them. These events are part of the published (not ubiquitous language), meaning changes could impact external systems.")),(0,i.kt)("h4",{id:"domain-invariants"},"Domain Invariants"),(0,i.kt)("p",null,"Domain invariants are the policies and conditions that must always be met in a specific context. They basically determine what is possible and what is prohibited in the context."),(0,i.kt)("p",null,"These invariants need to be enforced by the objects themselves, in particular when applicable to entities and aggregate roots. Examples of invariants are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Balance cannot be less than $0"),(0,i.kt)("li",{parentName:"ul"},"Age cannot be less than 18 or greater than 150"),(0,i.kt)("li",{parentName:"ul"},"Items out of stock cannot be sold")),(0,i.kt)("p",null,"In essence, if the domain has rules such as these, then they need to be applied and a domain object should not exist with following said rules."),(0,i.kt)("h4",{id:"domain-errors"},"Domain Errors"),(0,i.kt)("p",null,"Ideally, errors are prevented rather than handled, but we live in a complex world and need to be realistic. Errors will happen and they should form an intrinsic part of the domain model and domain layer."),(0,i.kt)("p",null,"The beauty of a high-quality domain model, and subsequently a well-defined domain layer is that it is much easier to detect errors during the use of the application, and return an explicit error type, rather than throwing the session and not returning an error."),(0,i.kt)("p",null,"Complex domains with many rules and different contexts, will consequently generate many errors that are not exceptions, but simply part of the business logic. When an instance occurs that is contrary to a defined rule, then an error can be returned to the user so it can be handled accordingly. This allows error handling and tracing much easier, which means it's also possible to continuously improve the application and performance."),(0,i.kt)("p",null,"In fact, to take it one step further, given the clear separation between application, user interface and domain, anything processed in the application or domain layer should never throw an HTTP exception or statuses given it doesn\u2019t have the context (if you\u2019ve followed the pattern correctly). A more suitable solution is to create domain errors with clear error A better approach is to create custom error classes with appropriate error descriptions."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")," it is important to distinguish between domain errors and exceptions. There are situations where exceptions happen that are outside of our control, and it is best to throw these exceptions to not risk and security concerns. Moreover, if these exceptions are not thrown, it could allow the system to run in an incorrect state which could have unexpected (and most likely unwanted) consequences.")),(0,i.kt)("h4",{id:"domain-services"},"Domain Services"),(0,i.kt)("p",null,"When multiple entities or value objects have a shared responsibility, we aim to create a domain service that encapsulates domain logic and represents business concepts. Normally, domain services represent a rule or policy and do not have a state nor an identity."),(0,i.kt)("p",null,"Domain services execute their tasks by orchestrating entities and value objects and are triggered either through a dependency injection container (from the application layer), or through passing an instance of the domain service to the entity in the domain layer. For example, a domain service can subscribe to specific domain events and perform its tasks when that event happens."),(0,i.kt)("p",null,"Alternatively, domain services can represent a contract for external service, protecting our domain model from external influences"),(0,i.kt)("h3",{id:"infrastructure-layer"},"Infrastructure Layer"),(0,i.kt)("p",null,"The final layer is the infrastructure layer which is used to separate the core business domain from the technical implementation. This layer is responsible for encapsulating technology such as the implementation of databases, storing and retrieving messages, events, entities, I/O services to access external resources and other framework related code."),(0,i.kt)("p",null,"As mentioned above, lower layers do not initiate actions on layers above them, only the other way around. Therefore, the infrastructure layer receives requests from the domain and doesn\u2019t have any knowledge about the domain it's serving. Infrastructure layers should be domain agnostic."),(0,i.kt)("p",null,"A common example to explain the infrastructure layer is the sending of an email. If an action is initiated by an application service in the application layer to send a message, that request is sent to a message-sending interface in the infrastructure layer and the message is sent. However, the fact that there is this decoupling allows you to change how the message is sent. It could be email, fax or another other option. Moreover, you greatly simplify the application layer by not having to explain how to send a message, but simply defining that a message needs to be sent."),(0,i.kt)("p",null,"The elegance of DDD is that by separating the infrastructure layer, you\u2019re isolating a very volatile layer (the infrastructure layer), from the more stable domain layer. It's possible to swap technological components / infrastructure services quite easily, which can improve performance or reduce costs significantly. In fact, the anticorruption-layer (ACL) pattern is frequently used in this layer to ensure clear separation between the two."),(0,i.kt)("p",null,"At its core, the infrastructure layer has adaptors, repositories (similar to databases), persistence models and many other services."),(0,i.kt)("h4",{id:"adapters"},"Adapters"),(0,i.kt)("p",null,"Adapters allow systems to interact with external systems by receiving, storing and providing data when requested. Think of persistence, sending emails or messages, requesting 3rd party APIs or message brokers. They are essentially the implementation code for ports (mentioned above) to the outside world. They \u201cadapt\u201d depending on the external user and can also be used to interact with different domains inside an application to reduce coupling between two modules."),(0,i.kt)("p",null,"Every adaptor requires a port through which the interaction with an application can take place using a specific technology. The number of adapters possible is almost unlimited and really dependent on the use cases. A REST controller for example is a type of adapter that allows clients to interact with a system."),(0,i.kt)("h4",{id:"repositories"},"Repositories"),(0,i.kt)("p",null,"A repository is where all the code is placed that handles operations over aggregates (entities and value objects). It basically performs the task of an intermediary between the domain model and the data mapping. It should be part of the ubiquitous language and reflects business concepts."),(0,i.kt)("p",null,"Accessing data should be done through specific logic and functionality, and repositories define, centralize and encapsulate that logic and functionality. This is another example of isolating and abstracting code that would otherwise complicate and obscure the domain logic. This decoupling ensures that the technology and infrastructure used to access databases is outside of the domain model."),(0,i.kt)("h4",{id:"data-access-objects-daos"},"Data Access Objects (DAOs)"),(0,i.kt)("p",null,"DAOs go hand in hand with repositories and basically define the relationship between relational databases and the application. More specifically, it encapsulates how the CRUD (create, retrieve, update, delete) operations are executed."),(0,i.kt)("p",null,"Another way to think about DAOs is that they define the workers that actually go and execute the operations, while the repositories provide the interface for the application to access those operations."),(0,i.kt)("h4",{id:"persistence"},"Persistence"),(0,i.kt)("p",null,"Entities, Aggregates and Value Objects have data modeled so it includes domain logic (business rules). This data and logic, in its raw form, may not be in the ideal shape to be saved to a database, or may required changes depending on the type of database selected."),(0,i.kt)("p",null,"Given this, a persistence model is required that can create the desired shape to be best represented in a particular database.\nAnd, following the key philosophy of DDD which is the separation of concerns and simplifying as much as possible the domain layer, this persistence models should be managed by the infrastructure layer and be of no concern to the domain layer."),(0,i.kt)("p",null,"There are various possible models and optimizations that can be implemented for different purposes including object-relational mapping (ORM), schemas, read/write models (CQRS) or even custom models."),(0,i.kt)("p",null,"As applications grow, so does the data and there may be a need to make changes to the database to improve performance, security or data integrity. This redesign can only be possible if there is a segregation between the domain layer and the persistence model. In fact, you could even consider changing databases altogether, something that is highly unlikely in systems that do not have this segregation."),(0,i.kt)("p",null,"A key note to consider is that separating domain and persistence models does require some effort, and Bitloops Language aims to reduce the effort required, nevertheless the pros and cons should be considered."),(0,i.kt)("h2",{id:"ddd-benefits--challenges"},"DDD: Benefits & Challenges"),(0,i.kt)("p",null,"Domain-Driven Design does have a steep learning curve, however, the benefits greatly compensate for the investment required to learn and implement it. Moreover, tools such as Bitloops support developers in building the DDD way in a smoother, quicker and more intuitive way."),(0,i.kt)("p",null,"In the past DDD was considered suitable for only complex projects, however, it is much easier to learn how to implement DDD in less complex projects, and be prepared when the project does become complex."),(0,i.kt)("h3",{id:"benefits"},"Benefits"),(0,i.kt)("p",null,"DDD provides many benefits such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Clear communication across all teams - particularly important for complex systems and large organizations"),(0,i.kt)("li",{parentName:"ul"},"Clarity of the domain model which ensure better and closer alignment with business goals and objectives"),(0,i.kt)("li",{parentName:"ul"},"Ability to manage complexity more effectively and efficiently by involving more resources (non-technical as well as technical that don\u2019t have the \u201chistory\u201d) in product development"),(0,i.kt)("li",{parentName:"ul"},"Providing scalability options"),(0,i.kt)("li",{parentName:"ul"},"Clearer code with self-descriptive class & function names through the ubiquitous language"),(0,i.kt)("li",{parentName:"ul"},"Delineation of potential microservice candidates with the identification of bounded contexts and context maps"),(0,i.kt)("li",{parentName:"ul"},"Robustness through the separation of concerns and the segregation of architectural components"),(0,i.kt)("li",{parentName:"ul"},"Improved flexibility as the system can be manipulated, improved or extended with ease given the structural design and object-oriented structure")),(0,i.kt)("h3",{id:"challenges"},"Challenges"),(0,i.kt)("p",null,"Domain-Driven Design is not easy to implement and does present some challenges, namely:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This collection of patterns requires conscious effort by the entire team to learn and understand"),(0,i.kt)("li",{parentName:"ul"},"Experienced and knowledgeable domain experts are crucial to develop and model the domain model"),(0,i.kt)("li",{parentName:"ul"},"There isn\u2019t a clear framework for how to apply it ","[something Bitloops is correcting]"),(0,i.kt)("li",{parentName:"ul"},"As with any activity that provides long-term benefits to a software developer, it takes time, experience and practice"),(0,i.kt)("li",{parentName:"ul"},"Experience is required to be practical - there are clearly deviations that should be considered at appropriate times, and refactored when necessary"),(0,i.kt)("li",{parentName:"ul"},"DDD focuses on solving domain complexities and is therefore probably inappropriate for highly technical projects"),(0,i.kt)("li",{parentName:"ul"},"Whilst DDD is not suitable for all projects, it increasingly makes sense to apply DDD across many more projects and not only complex projects given the benefit of tools such as Bitloops")),(0,i.kt)("h2",{id:"other-ddd-complimentary-patterns"},"Other DDD complimentary patterns"),(0,i.kt)("h3",{id:"ddd--service-oriented-architecture"},"DDD & Service Oriented Architecture"),(0,i.kt)("p",null,"Given how DDD encourages developers to partition systems into separate, cohesive and loosely coupled elements, it's only natural that it supports design principles that depend on this architecture."),(0,i.kt)("p",null,"Service oriented architecture (SOA) is a design pattern upon which software is built based on business processes, and the application layer is designed around services. Each service communicates with other services using a common language, and each individual service can be monitored separately. In essence, with SOA, the services are the most important aspect of the system."),(0,i.kt)("h3",{id:"domain-driven-design-microservices"},"Domain-Driven Design Microservices"),(0,i.kt)("p",null,"Domain-driven design, as described in detail above, is all about building a structured and well defined system that best models a business domain. This means breaking a system into specific parts and separating business logic from technical requirements, and even breaking up these into smaller modules that work well together."),(0,i.kt)("p",null,"Microservices are small services that do a particular function or solve a particular business problem. Building microservices is a software development technique (a variant of service-oriented architecture) that structures an application as a collection of services that are loosely coupled, meaning they can be managed and deployed independently, which give teams much wanted freedom and flexibility."),(0,i.kt)("p",null,"Given these two descriptions, it's easy to see how DDD and Microservices could be a good match. And indeed, if you do think about your system and decompose it into microservices, you are able to define these microservices into specific domains, and take advantage of many of the domain-driven principles that help build robust and flexible systems."),(0,i.kt)("p",null,"There are many variants in terms of how DDD is applied with microservices, but the common theme is to build a domain model for each microservice, and have its own database. This allows the microservice (and the team) to choose the best implementation for their domain."),(0,i.kt)("h3",{id:"ddd-and-event-driven-architecture"},"DDD and Event-Driven Architecture"),(0,i.kt)("p",null,"Similar to SOA, DDD is a great way to implement event-driven architectures. The benefits of building a system the DDD way with clear separation of concern, command query segregation and creation of clearly defined domain objects, will empower the development of an event-driven architecture."),(0,i.kt)("p",null,"Event-driven architecture is a software development paradigm that focuses on producing, detecting (or listening), consuming and reacting to events. Events are basically triggers for the next service or function to be executed, and the entire system can be based on events triggering the required business steps."),(0,i.kt)("h3",{id:"object-oriented-programming-oop"},"Object Oriented Programming (OOP)"),(0,i.kt)("p",null,"OOP is a style of programming that considers the Objects as the central figure of a program, and it\u2019s a very important concept when designing and implementing the domain layer. Understanding of concepts such as inheritance, encapsulation and polymorphism is critical to building comprehensive and robust domain models."),(0,i.kt)("p",null,"Most domain elements (more specifically entities and value objects in DDD) have both state (attributes) and behavior (methods of operations), and they should match real-world objects. And, just like in the real world, these objects need to work closely together with other elements such as services, repositories or factories, as well as being able to be traced, audited, rolled-back, etc. however, they need to do so in a well structured manner so as to not confuse, overcomplicate and overwhelm the domain logic."),(0,i.kt)("p",null,"This is where DDD comes to the rescue to provide an elegant design to manage all of these elements in a well structured way, and why concepts such as dependency injection and aspect oriented programming are also important to learn in order to properly minimize tight coupling, better define modules and enhance how cross-cutting elements operate throughout the application."),(0,i.kt)("h3",{id:"dependency-injection-di"},"Dependency Injection (DI)"),(0,i.kt)("p",null,"The concept of dependency injection is exactly what the name infers: it\u2019s about supplying (injecting) a resource (data, service, repository, etc.) that a function or piece of code requires. This is yet again an example of how to simplify your domain logic and domain layer, by removing the configuration and dependency code out of a domain object."),(0,i.kt)("p",null,"An application will always have software that depends on other resources to complete its intended purpose, and it needs to know where its located, how to access it and how to communicate with it."),(0,i.kt)("p",null,"The greatest advantages of dependency injection is the ability to run unit tests more efficiently and to improve the general reusability of code. This is particularly important in larger and complex applications. The only disadvantage is that when troubleshooting, the bug may be located in code that has been separated from the domain and application layer."),(0,i.kt)("p",null,"Nevertheless, dependency injection supports a cleaner and more loosely coupled system by not overcomplicating code. For example, an entity can reference a repository through a dependency injection."),(0,i.kt)("h3",{id:"aspect-oriented-programming-aop"},"Aspect Oriented Programming (AOP)"),(0,i.kt)("p",null,"As mentioned before, anything that is not business essential, clutters code or makes it less understandable, should be removed from the domain and application layer. This is where AOP comes into play as it manages all behaviors or requirements that are not key to the business to be managed and executed."),(0,i.kt)("p",null,"Whilst most programming paradigms encourage some sort of partitioning of systems into manageable parts or modules, there are always some aspects that cannot be separated as they\u2019re precisely necessary across multiple components or modules of a system. Therefore, these services are generally called cross-cutting or horizontal concerns, and need to be managed in a specific way."),(0,i.kt)("p",null,"These requirements are normally services such as logging, auditing or state change tracking. Adding these requirements into the domain code would increase coupling or reduce modularity, and consequently decrease the quality of the system design. AOP helps reduce this tangling and scattering of code across the codebase."),(0,i.kt)("h3",{id:"behavior-driven-development-bdd"},"Behavior-Driven Development (BDD)"),(0,i.kt)("p",null,"The development of a domain model, and the creation of clear domain and application layers allows for a much better understanding and representation of the behaviors one expects from an application. This is where BDD plays a very intersecting role with DDD."),(0,i.kt)("p",null,"Behavior-driven development focuses on the behavioral aspects of a system. If use cases and business logic is developed taking into account the expected behaviors, and what to do during exceptions, then it is possible to build better and more valuable systems. After all, domain objects are simply a representation and encapsulation of state and behavior, so the creation of these domain objects can benefit greatly from the use of BDD concepts."),(0,i.kt)("p",null,"The other great benefit is that BDD takes applications one step closer towards test-driven development, which is another software development practice that makes systems more flexible, more robust and allow for faster development."),(0,i.kt)("h2",{id:"bitloops---simplifying-ddd"},"Bitloops -> Simplifying DDD"),(0,i.kt)("p",null,"Domain-Driven Design is a powerful concept that has changed (and will continue to change) how software systems are designed and built. Its principles are universal and can (and should) be learnt by domain experts, modelers, software architects, testers (QA), product managers and of course, developers."),(0,i.kt)("p",null,"Teams that are trained in the principles, methodologies and patterns of DDD will apply the domain first, infrastructure second philosophy, and build systems are better reflect the core business goals and objectives"),(0,i.kt)("h3",{id:"ddd-programming-language"},"DDD Programming Language"),(0,i.kt)("p",null,"The first thing to clarify is that DDD is not a programming language or toolkit. It is essentially a methodology of understanding complex problems and designing domain models that can best be reflected with code."),(0,i.kt)("p",null,"However, there are specific technical concepts and tools that ensure the implementation of the domain model in code follows best practices. These concepts and tools can easily be forgotten or not identified, so it would be extremely helpful if there were a developer tool that guided developers into building software that does ensure adequate separation of concerns, high cohesion and loose coupling."),(0,i.kt)("p",null,"This developer platform could even support other software development best practices such as BDD or TDD by using use cases and behavior to more accurately model the domain and expected outcomes. Moreover, a platform such as this could take it to the next level and also support developers in building the required technical infrastructure in the best way possible such as repositories, controllers, ports and adaptors."),(0,i.kt)("p",null,"The easy and intuitive implementation of these concepts and tools during the software development process will make these systems easier to understand, change and maintain. These applications will also be auditable and testable, which means new features and products, or refactoring to improve performance, can be executed with confidence."),(0,i.kt)("p",null,"This is where Bitloops comes in as it has been designed and developed to help developers build systems that follow, support and actually encourages the usage of specific tools that reflect best practices in design and software development such as DDD, BDD, TDD, Layered / Hexagonal Architecture and SOLID principles."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Domain-driven design is clearly a valid and well-thought-out way to manage the development of software for complex projects. Without implementing DDD, or other design patterns and methodologies, large and complex projects will very quickly become impossible to manage, leading to long and expensive development cycles, which ultimately lead a company to become uncompetitive."),(0,i.kt)("p",null,"DDD does have a steep learning curve and, in the past, was viewed as only suitable for large enterprises. However, given the increased complexity of standard projects, as well as the natural complexity of technology in general, learning DDD will no doubt improve every developer's ability to build better code."),(0,i.kt)("p",null,"There is no doubt that learning and implementing DDD (or other software design best practices) will improve the quality of the software of an application, and we at Bitloops are keen to not only provide developers with the insights and learnings to build better software, but also the tools to implement these best practices as effectively as possible."))}u.isMDXComponent=!0}}]);