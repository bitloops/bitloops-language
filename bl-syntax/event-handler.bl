// BL
IntegrationEventHandler MoneyDepositedIntegrationHandler() {
  //should we support use case as dependency
  // If Subscribed to integration-event, we need to define what version
  // and get the eventTopic to subscribe from it
  
  eventVersion: 'v1';
  
  //Should we have void as return type for visibility
  handle(event: [banking][banking]MoneyDepositedIntegrationEvent) {
    const data = event.data;
    const accountId = data.accountId;

    const command = IncrementDepositsCommand.create({ accountId: accountId.toString() });

    this.commandBus.send(command);
  }
}

// TS
export class MoneyDepositedIntegrationHandler {
  constructor(private commandBus: Infra.CommandBus.ICommandBus) {}

  public async handle(event: MoneyDepositedIntegrationEvent): Promise<void> {
    const { data } = event;

    const command = new IncrementDepositsCommand({ accountId: data.accountId });

    await this.commandBus.send(command);
    console.log(`[AfterMoneyDepositedIntegrationEvent]: Successfully sent Increment Command`);
  }
}
// Maybe this should be generated in the setup
// and in subscriptions
const moneyDepositedIntegrationHandler = new MoneyDepositedIntegrationHandler(commandBus);
  integrationEventBus.subscribe<MoneyDepositedIntegrationEvent>(
    MoneyDepositedIntegrationEvent.getEventTopic('v1'),
    (event) => {
      moneyDepositedIntegrationHandler.handle(event);
    },
  );

// AST

type TIntegrationEventHandlerIdentifier = string;

type TIntegrationEventHandler = {
  integrationEventHandler: {
    integrationEventHandlerIdentifier: TIntegrationEventHandlerIdentifier;
    eventVersion: string; // or probably StringLiteral
    handle: THandle;
  } & TParameterList & TEventHandlerBusDependencies;
}

type THandle = {
  statements: TStatements;
} & TParameter;
// But in grammar use a paremeter with IntegrationEventIdentifier as type, not generic bitloops primary type
  
//1. In TS we can check if query bus/command bus are unused and not include them in the dependencies
//2. In IntermediateAST -> CompleteAST we need to find the type of customerQueryResult

DomainEventHandler SendEmailAfterDepositsIncrementedDomainEventHandler(customerService: CustomerServicePort) {
  //should we support use case as dependency
  // If Subscribed to integration-event, we need to define what version
  // and get the eventTopic to subscribe from it
  
  //Should we have void as return type for visibility
  handle(event: DepositsIncrementedDomainEvent) {
    const account = event.account;
    const accountId = account.id;

    const email = this.customerService.getEmailByAccountId(accountId.toString());

    const command = SendEmailVerificationCommand.create({ accountId: accountId.toString(), email });

    this.commandBus.send(command);
  }
}

// AST
type TDomainEventHandlerIdentifier = string;

type TDomainEventHandler = {
  domainEventHandler: {
    domainEventHandlerIdentifier: TDomainEventHandlerIdentifier;
    handle: THandle;
  } & TParameterList & TEventHandlerBusDependencies;
}

type THandle = {
  statements: TStatements;
} & TParameter;

// TS 
export class SendEmailAfterDepositsIncrementedHandler implements Application.IHandle {
  constructor(
    private commandBus: Infra.CommandBus.ICommandBus,
    private queryBus: Infra.QueryBus.IQueryBus,
    private customerService: ICustomerService,
  ) {}

  public async handle(event: DepositsIncrementedDomainEvent): Promise<void> {
    const { data } = event;
    const depositsCounter = data.deposits.counter;

    let emailContent = '';
    if (data.isFirstDeposit()) {
      emailContent = 'Congrats, you have made your first deposit!';
    } else if (data.hasReachedMilestoneDeposits()) {
      emailContent = `Congrats, you have made ${depositsCounter} deposits!`;
    } else {
      return;
    }

    const destinationEmail = await this.customerService.getEmailByAccountId(data.id.toString());

    const command = new SendEmailCommand({
      origin: 'ant@ant.com',
      destination: destinationEmail,
      content: emailContent,
    });

    await this.commandBus.send(command);
    console.log(`[AfterMoneyDepositsIncrementedDomainEvent]: Successfully sent SendEmail Command`);
  }
}

// Maybe this should be generated in the setup
// and in subscriptions
domainEventBus.subscribe<DepositsIncrementedDomainEvent>(
  DepositsIncrementedDomainEvent.getEventTopic(),
  (event) => {
    sendEmailAfterDepositsIncrementedHandler.handle(event);
  },
);