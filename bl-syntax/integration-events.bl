
// Structs or DTOs for each version of the integration event
Struct TodoIntegrationSchemaV1 {
  string accountId;
  int32 balanceAmount;
}

Struct TodoIntegrationSchemaV2 {
  string accountId;
  int32 amount;
}

Props MoneyDepositedInputProps {
  string accountId;
  int32 balanceAmount;
}; 

// IntegrationEvent MoneyDepositedIntegrationEvent {
//   input: MoneyDepositedInputProps;
//   versions: ['v1.0.0' , 'v2'];

//   // Basically just needs to define a mapper of data for each version
//   // Predefined method names based on provided versions, (concat of standard word + CammelCase version)
//   toIntegrationDataV1(data): TodoIntegrationSchemaV1 {
//     return {
//       accountId: data.accountId,
//       balanceAmount: data.balanceAmount,
//     };
//   }

//   toIntegrationDataV2(data): TodoIntegrationSchemaV2 {
//     return {
//       accountId: data.accountId,
//       amount: data.balanceAmount,
//     };
//   }

//   // Needs to define the topic for each version, we could have a default topic
//   getEventTopic(version) {
//     return `integration.${MoneyDepositedIntegrationEvent.name}.${version}`;
//   }
// }

/**
 * input can be a DomainEvent (or Props in the future)
 * in the case of a DomainEvent, we generate the domainEventHandler that publishes the integration event
 */
// @disabled['v2']
IntegrationEvent MoneyDepositedIntegrationEventHandler(input: MoneyDepositedToAccountDomainEvent) {
  // Maybe have disable list of versions?

  'v1.0.9' : TodoIntegrationSchemaV1 {
    const fullName = `${input.firstName} ${input.lastName}`;
    return {
      accountId: event.account.id.toString(),
      balanceAmount: input.balanceAmount,
    };
  }

  'v2' : TodoIntegrationSchemaV2 {
    return {
      accountId: input.accountId,
      amount: input.balanceAmount,
    };
  }

  // Needs to define the topic for each version, we could have a default topic
  // This could be automated??
  // getEventTopic(version) {
  //   return `integration.${MoneyDepositedIntegrationEvent.name}.${version}`;
  // }
}

//AST

type TVersionName = string; // strinliteral

type TVersionMapper = {
  versionMapper: {
    versionName: TVersionName;
    statements: TStatements;
    returnSchemaType: TStructIdentifier;
  }
};

type TIntegrationEventInput = {
  integrationEventInput: TParameter; // in syntax will be DomainEventIdentifier | PropsIdentifier;
}

type TIntegrationEventIdentifier = string;

type TIntegrationEvent = {
  integrationEvent: {
    integrationEventIdentifier: TIntegrationEventIdentifier;
  } & TVersionMapper & TIntegrationEventInput;
}

//Typescript
type TodoIntegrationSchemaV1 = {
  accountId: string;
  balanceAmount: number;
};

type MoneyDepositedIntegrationEventPayload = TodoIntegrationSchemaV1;

type MoneyDepositedInput = {
  accountId: string;
  balanceAmount: number;
}; // v1 | v2 ...

type ToIntegrationDataMapper = (data: MoneyDepositedInput) => MoneyDepositedIntegrationEventPayload;

export class MoneyDepositedIntegrationEvent extends Infra.EventBus
  .IntegrationEvent<MoneyDepositedIntegrationEventPayload> {
  static versions = ['v1'];
  static versionMappers: Record<string, ToIntegrationDataMapper> = {
    v1: MoneyDepositedIntegrationEvent.toIntegrationDataV1,
  };

  constructor(data: MoneyDepositedIntegrationEventPayload, version: string, uuid?: string) {
    const metadata = {
      id: uuid,
      fromContextId: CustomerCreated.fromContextId,
      version,
    };
    super(MoneyDepositedIntegrationEvent.getEventTopic(version), data, metadata);
  }

  static create(params: MoneyDepositedInput): MoneyDepositedIntegrationEvent[] {
    return MoneyDepositedIntegrationEvent.versions.map((version) => {
      const mapper = MoneyDepositedIntegrationEvent.versionMappers[version];
      const data = mapper(params);
      return new MoneyDepositedIntegrationEvent(data, version);
    });
  }

  static toIntegrationDataV1(data: MoneyDepositedInput): TodoIntegrationSchemaV1 {
    return {
      accountId: data.accountId,
      balanceAmount: data.balanceAmount,
    };
  }

  static getEventTopic(version?: string) {
    const topic = `integration.${MoneyDepositedIntegrationEvent.name}`;

    const eventTopic = version === undefined ? topic : `${topic}.${version}`;
    return eventTopic;
  }
}
// in case of DomainEvent as input it will generate the publish handler
export class MoneyDepositedPublishIntegrationEventHandler implements Application.IHandle {
  constructor(private eventBus: Infra.EventBus.IEventBus) {
    // here get the integration event bus from container, instead from dependency
  }

  public async handle(event: MoneyDepositedToAccountDomainEvent): Promise<void> {
    const { account } = event;

    const { id: accountId, balance } = account;
    const events = MoneyDepositedIntegrationEvent.create({
      accountId: accountId.toString(),
      balanceAmount: balance.amount,
    });

    const eventsWithTopic = events.map((event) => {
      return { message: event, topic: event.eventTopic };
    });

    await this.eventBus.publishMany(eventsWithTopic);

    console.log(
      `[AfterTodoCreatedDomainEvent]: Successfully published MoneyDepositedIntegrationEvent`,
    );
  }
}

// Maybe this should be generated in the setup
// and the subscription of the domain event
const moneyDepositedIntegrationEventHandler = new MoneyDepositedPublishIntegrationEventHandler(
  integrationEventBus,
);

await domainEventBus.subscribe<MoneyDepositedToAccountDomainEvent>(
  MoneyDepositedToAccountDomainEvent.getEventTopic(),
  (event) => {
    moneyDepositedIntegrationEventHandler.handle(event);
  },
);