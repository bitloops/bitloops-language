---
sidebar_label: RepoPort
title: Repository Port - Basic Syntax 
description: RepoPort syntax on Bitloops Language - Repository Ports allows developers to declare an interface to connect different databases easily using a Repository Adapter.
keywords: [bitloops, bitloops language, basic syntax, programming language, variables, types, objects, data types, classes, interfaces, modules, functions, loops, services, repoport, repository port]
---

# RepoPort

The RepoPort component is a tool which will help you declare an interface in order to plug in different databases easily (via RepositoryAdapter).
It acts as an interface, in order to declare methods which will be later be implemented by the corresponding RepoAdapter. Its name and functionality is inspired by the Repository Pattern.

```
More information not available yet!
```

### Syntax

```
Not available yet!
```

## CRUDRepoPort

The CRUDRepoPort is a RepoPort which could be used in order to get out of the box [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) operations functionality ready to utilize, for a specific **Aggregate**.

### Syntax

```typescript
 RepoPort MyHelloRepoPort<MyAggregate> extends CRUDRepoPort;
```

In order to utilize it, a **RepoPort** should be declared as the code above.
More specifically the command starts with the reserved word: **RepoPort** indicating the type. Then the name of the repository is declared (`MyHelloRepoPort` in this case). Afterwards the name of the **Aggregate** which corresponds to the specific repository should should be declared inside of brackets `<>` then the reserved word **extends** is used in order to indicate that this repository will inherit all the functionality of a **RepoPort**.

The CRUDRepoPort declaration will under the hood create an interface with already declared CRUD methods for the specified **RepoPort** (`MyHelloRepoPort` in the example above) in the target language. This will include CRUD operations for the **Aggegate** as well for all the **Entities** it contains.

The **Aggregate** declaration `<MyAggregate>` is necessary in order for the automatic code generation to take place. More specifically the code generation algorithm will identify all the **Entities** belonging to the **Aggregate**, and create all the CRUD methods with the respective data types.

### Example

Let's say that you model a car as your **Aggregate**, and your `CarAggregate` has fields like (vendor, model, year, etc.), and it contains an `EngineEntity` **Entity** (will contain an Id of the specific engine and information for the specific engine like vendor, productCode etc.) and a collection of `WheelEntity` **Entity** (will contain information like vendor, productCode, materialType, yearOfConstruction, etc.). The wheels collection of wheel entities is a collection since it is assumed in this model that the `CarAggregate` will have 4 wheels which could be completely different.

In this case you will declare the specific **RepoPort** as follows:

```typescript
 RepoPort CarRepoPort<CarAggregate> extends CRUDRepoPort;
```

The system will automatically create the following CRUD operations signature declarations on the CarRepoPort, under the hood:

```typescript
// All these will be transparent for the user
// for the CarAggregate
getAll(): CarAggregate[]
getById(carId: Id): CarAggregate
save(car: CarAggregate): void
update(car: CarAggregate): void
delete(carId: Id): void

// for the  Wheels
getWheelById(carId: Id, wheelId: Id): WheelEntity
getAllWheels(carId): WheelEntity[] // This can be autogenerated since we know that wheels are a collection inside the CarAggregate

// for the Engine
getEngineById(carId: Id, wheelId: Id): EngineEntity
```

The methods above will then be available to be used inside a **UseCase** by default like this, respectively:

```typescript
// for the CarAggregate
carRepo.getAll();
carRepo.getById(carId);
carRepo.save(car);
carRepo.update(car);
carRepo.delete(carId);

// for the  Wheels
carRepo.getWheelById(carId, wheelId);
carRepo.getAllWheels(carId);

// for the Engine
carRepo.getEngineById(carId, wheelId);
```

Note that the autogenerated methods for the entities **will not mutate the state** - since the state can be mutated only via the **Aggregate** so they could only represent queries.

The commands above will return all the information for the specific `CarAggregate` or its Entities.

---

More custom methods can be added to a **RepoPort** which extends the **CRUDRepoPort** by defining specific methods, with the synstax displayed below:

```typescript
 RepoPort CarRepoPort<CarAggregate> extends CRUDRepoPort {
 // Not available yet! Similar to the declaration of the RepoPort
 };
```

---

Finally in order to be able to connect a specific database to the specific RepoPort, a declaration of the specific concretion for this port via a ready to use adapter should be added at the setup. The syntax for using a mongo database could be as follows (for more information check the [RepoAdapters section](./repository-adapter.md)):

```typescript
 RepoAdapters.Mongo concretes [Demo][Hello World]MyHelloRepoPort;
```
